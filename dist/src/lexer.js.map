{"version":3,"file":"lexer.js","sourceRoot":"","sources":["../../src/lexer.ts"],"names":[],"mappings":"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","sourcesContent":["import { createToken, Lexer, TokenType } from \"chevrotain\";\n\nenum TokenName {\n  AdditionOperator = \"AdditionOperator\",\n  Plus = \"Plus\",\n  Minus = \"Minus\",\n  MultiplicationOperator = \"MultiplicationOperator\",\n  Multi = \"Multi\",\n  Div = \"Div\",\n\n  LParen = \"LParen\",\n  RParen = \"RParen\",\n\n  WhiteSpace = \"WhiteSpace\",\n  Comma = \"Comma\",\n\n  Function = \"Function\",\n  Reference = \"Reference\",\n\n  NumberLiteral = \"NumberLiteral\",\n  DStringLiteral = \"DStringLiteral\",\n  SStringLiteral = \"SStringLiteral\",\n  BooleanLiteral = \"BooleanLiteral\",\n\n  ComparisonOperator = \"ComparisonOperator\",\n  Lt = \"Lt\",\n  Gt = \"Gt\",\n  Lte = \"Lte\",\n  Gte = \"Gte\",\n  Eq = \"Eq\",\n}\n\nconst AdditionOperator = createToken({\n  name: TokenName.AdditionOperator,\n  pattern: Lexer.NA,\n});\nconst Plus = createToken({\n  name: TokenName.Plus,\n  pattern: /\\+/,\n  categories: AdditionOperator,\n});\nconst Minus = createToken({\n  name: TokenName.Minus,\n  pattern: /-/,\n  categories: AdditionOperator,\n});\n\nconst MultiplicationOperator = createToken({\n  name: TokenName.MultiplicationOperator,\n  pattern: Lexer.NA,\n});\nconst Multi = createToken({\n  name: TokenName.Multi,\n  pattern: /\\*/,\n  categories: MultiplicationOperator,\n});\nconst Div = createToken({\n  name: TokenName.Div,\n  pattern: /\\//,\n  categories: MultiplicationOperator,\n});\n\nconst LParen = createToken({\n  name: TokenName.LParen,\n  pattern: /\\(/,\n});\nconst RParen = createToken({\n  name: TokenName.RParen,\n  pattern: /\\)/,\n});\n\nconst Function = createToken({\n  name: TokenName.Function,\n  pattern: /[A-Za-z_]+[A-Za-z_0-9.]*/,\n});\nconst Reference = createToken({\n  name: TokenName.Reference,\n  pattern: /\\{[A-Za-z_]+\\}/,\n});\n\nconst Comma = createToken({\n  name: TokenName.Comma,\n  pattern: /,/,\n});\nconst WhiteSpace = createToken({\n  name: \"WhiteSpace\",\n  pattern: /\\s+/,\n  group: Lexer.SKIPPED,\n});\n\nconst BooleanLiteral = createToken({\n  name: TokenName.BooleanLiteral,\n  pattern: /TRUE|FALSE/i,\n});\nconst NumberLiteral = createToken({\n  name: TokenName.NumberLiteral,\n  pattern: /[0-9]+[.]?[0-9]*([eE][+\\-][0-9]+)?/,\n});\nconst DStringLiteral = createToken({\n  name: TokenName.DStringLiteral,\n  pattern: /\"(\"\"|[^\"])*\"/,\n});\nconst SStringLiteral = createToken({\n  name: TokenName.SStringLiteral,\n  pattern: /'(''|[^'])*'/,\n});\n\nconst ComparisonOperator = createToken({\n  name: TokenName.ComparisonOperator,\n  pattern: Lexer.NA,\n});\nconst Lt = createToken({\n  name: TokenName.Lt,\n  pattern: /</,\n  categories: ComparisonOperator,\n});\nconst Gt = createToken({\n  name: TokenName.Gt,\n  pattern: />/,\n  categories: ComparisonOperator,\n});\nconst Lte = createToken({\n  name: TokenName.Lte,\n  pattern: /<=/,\n  categories: ComparisonOperator,\n});\nconst Gte = createToken({\n  name: TokenName.Gte,\n  pattern: />=/,\n  categories: ComparisonOperator,\n});\nconst Eq = createToken({\n  name: TokenName.Eq,\n  pattern: /==/,\n  categories: ComparisonOperator,\n});\n\nconst tokensByPriority = [\n  WhiteSpace,\n  Plus,\n  Minus,\n  Multi,\n  Div,\n  Lte,\n  Lt,\n  Gte,\n  Gt,\n  Eq,\n  LParen,\n  RParen,\n  DStringLiteral,\n  SStringLiteral,\n  BooleanLiteral,\n  NumberLiteral,\n  ComparisonOperator,\n  AdditionOperator,\n  MultiplicationOperator,\n  Function,\n  Reference,\n  Comma,\n];\n\nexport const FormulaLexer = new Lexer(tokensByPriority, {\n  ensureOptimizations: true,\n});\n\nexport type TokenTypeDict = { [key in TokenName]: TokenType };\nexport const tokens: TokenTypeDict = tokensByPriority.reduce(\n  (acc, tokenType) => {\n    acc[tokenType.name] = tokenType;\n    return acc;\n  },\n  {} as TokenTypeDict\n);\n"]}